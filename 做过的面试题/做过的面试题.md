# 面试题

#### 1.面向对象的特征：

```
1.抽象：
抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。
2.继承：
继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。
3.封装：
封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。
4. 多态性：
多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。
```



#### 2. final, finally, finalize 的区别 

```
final是一个修饰符，用于声明属性、方法和类,分别表示属性不可变、方法不可覆盖、类不可继承。
finally是异常处理语句结构的一部分,表示总是执行。
finalize是 Object类的一个方法,在垃圾收集器执行的时候,会调用被回收对象的此方法,可以覆盖此方法,提供垃圾收集时的其他资源回收,例如关闭文件等。
```

#### 3.Exception、Error、运行时异常与一般异常有何异同 

```

error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。
exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。
异常表示程序运行过程中可能出现的非正常状态
运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。
```

#### 4. 请写出5种常见到的runtime exception 

```
java.lang.NullPointerException 空指针异常；出现原因：调用了未经初始化的对象或者是不存在的对象。
java.lang.ClassNotFoundException 指定的类找不到；出现原因：类的名称和路径加载错误；通常都是程序试图通过字符串来加载某个类时可能引发异常。
java.lang.NumberFormatException 字符串转换为数字异常；出现原因：字符型数据中包含非数字型字符。
java.lang.IndexOutOfBoundsException 数组角标越界异常，常见于操作数组对象时发生。
java.lang.IllegalArgumentException 方法传递参数错误。
java.lang.ClassCastException 数据类型转换异常。
java.lang.NoClassDefFoundException 未找到类定义错误。
SQLException SQL异常，常见于操作数据库时的SQL语句错误。
java.lang.InstantiationException实例化异常。
java.lang.NoSuchMethodException 方法不存在异常。
```
#### 5.int 和 Integer 有什么区别，Integer的值缓存范围 

```
1 int与Integer的基本使用对比
（1）Integer是int的包装类；int是基本数据类型； 
（2）Integer变量必须实例化后才能使用；int变量不需要； 
（3）Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ； 
（4）Integer的默认值是null；int的默认值是0。

2 int与Integer的深入对比
（1）由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。

Integer i = new Integer(100);
Integer j = new Integer(100);
System.out.print(i == j); //false

（2）Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）

Integer i = new Integer(100);
int j = 100；
System.out.print(i == j); //true

（3）非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）

Integer i = new Integer(100);
Integer j = 100;
System.out.print(i == j); //false

（4）对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false

Integer i = 100;
Integer j = 100;
System.out.print(i == j); //true

Integer i = 128;
Integer j = 128;
System.out.print(i == j); //false

　　对于第4条的原因： java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)。而java API中对Integer类型的valueOf的定义如下，对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了。

public static Integer valueOf(int i){
    assert IntegerCache.high >= 127;
    if (i >= IntegerCache.low && i <= IntegerCache.high){
        return IntegerCache.cache[i + (-IntegerCache.low)];
    }
    return new Integer(i);
}

```

https://blog.csdn.net/chenliguan/article/details/53888018

#### 6.包装类，装箱和拆箱 

```
3 Java两种数据类型
3.1 Java两种数据类型分类
（1）基本数据类型，分为boolean、byte、int、char、long、short、double、float； 
（2）引用数据类型 ，分为数组、类、接口。

3.2 Java为每个原始类型提供了封装类
　　为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每 一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。

基本数据类型: boolean，char，byte，short，int，long，float，double
封装类类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double

4 基本解析
4.1 自动装箱：将基本数据类型重新转化为对象
    public class Test {  
        public static void main(String[] args) {  
            //声明一个Integer对象
            Integer num = 9;

            //以上的声明就是用到了自动的装箱：解析为:Integer num = new Integer(9);
        }  
    }  

　　9是属于基本数据类型的，原则上它是不能直接赋值给一个对象Integer的，但jdk1.5后你就可以进行这样的声明。自动将基本数据类型转化为对应的封装类型，成为一个对象以后就可以调用对象所声明的所有的方法。

4.2 自动拆箱：将对象重新转化为基本数据类型
 public class Test {  
        public static void main(String[] args) {  
            //声明一个Integer对象
            Integer num = 9;

            //进行计算时隐含的有自动拆箱
            System.out.print(num--);
        }  
    }  

　　因为对象时不能直接进行运算的，而是要转化为基本数据类型后才能进行加减乘除。对比：

/装箱
Integer num = 10;
//拆箱
int num1 = num;

5 深入解析
5.1 情况描述
   public class Test {  
        public static void main(String[] args) {  
            //在-128~127 之外的数
            Integer num1 = 128;   Integer num2 = 128;           
            System.out.println(num1==num2);   //false

            // 在-128~127 之内的数 
            Integer num3 = 9;   Integer num4 = 9;   
            System.out.println(num3==num4);   //true
        }  
    }  

　　解析原因：归结于java对于Integer与int的自动装箱与拆箱的设计，是一种模式：叫享元模式（flyweight）。 
　　加大对简单数字的重利用，Java定义在自动装箱时对于值从–128到127之间的值，它们被装箱为Integer对象后，会存在内存中被重用，始终只存在一个对象。 
而如果超过了从–128到127之间的值，被装箱后的Integer对象并不会被重用，即相当于每次装箱时都新建一个 Integer对象。

5.2 Integer源码解析
　　给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，源码如下：

public static Integer valueOf(String s, int radix) throws NumberFormatException {
        return Integer.valueOf(parseInt(s,radix));
    }

public static Integer valueOf(int i) {
        assert IntegerCache.high >= 127;
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }

　　IntegerCache是Integer的内部类，源码如下：

     /**
      * 缓存支持自动装箱的对象标识语义
      * -128和127（含）。
      *
      * 缓存在第一次使用时初始化。 缓存的大小
      * 可以由-XX：AutoBoxCacheMax = <size>选项控制。
      * 在VM初始化期间，java.lang.Integer.IntegerCache.high属性
      * 可以设置并保存在私有系统属性中
     */
    private static class IntegerCache {
        static final int low = -128;
        static final int high;
        static final Integer cache[];

        static {
            // high value may be configured by property
            int h = 127;
            String integerCacheHighPropValue =
                sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
            if (integerCacheHighPropValue != null) {
                int i = parseInt(integerCacheHighPropValue);
                i = Math.max(i, 127);
                // Maximum array size is Integer.MAX_VALUE
                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
            }
            high = h;

            cache = new Integer[(high - low) + 1];
            int j = low;
            for(int k = 0; k < cache.length; k++)
                cache[k] = new Integer(j++);
        }

        private IntegerCache() {}
    }
```
#### 7.重载和重写的区别 

```
重载(Overloading)

 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。

重载Overloading是一个类中多态性的一种表现。

 Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。

调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。

 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。



父类方法被默认修饰时，只能在同一包中，被其子类被重写，如果不在同一包则不能重写。

父类的方法被protoeted时，不仅在同一包中，被其子类被重写，还可以不同包的子类重写。

 

重写方法的规则：

1）、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。

2）、返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。

3）、访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private）

4）、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：

父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。

 

而重载的规则：

1）、必须具有不同的参数列表；

2）、可以有不同的返回类型，只要参数列表不同就可以了；

3）、可以有不同的访问修饰符；

4）、可以抛出不同的异常；



重载和重写（覆盖）的特点：




1. Override 特点

　　1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；

　　2、覆盖的方法的返回值必须和被覆盖的方法的返回一致；

　　3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；

　　4、被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。

2.Overload 特点

　　1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int, float)， 但是不能为fun(int, int)）；

　　2、不能通过访问权限、返回类型、抛出的异常进行重载；

　　3、方法的异常类型和数目不会对重载造成影响；

　　4、对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。




总结：


override（重写）

　　 1、方法名、参数、返回值相同。

　　 2、子类方法不能缩小父类方法的访问权限。

　　 3、子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。

　　 4、存在于父类和子类之间。

　　 5、方法被定义为final不能被重写。

　overload（重载）

　　1、参数类型、个数、顺序至少有一个不相同。 

　　2、不能重载只有返回值不同的方法名。

　　3、存在于父类和子类、同类中。
```
#### 8.抽象类和接口有什么区别 

```
相同点：
1)都是上层的抽象层。
2)都不能被实例化
3)都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不比提供具体的实现。
不同点：
1)在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。
2)一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。
```
#### 9.String、StringBuilder、 StringBuffer 

https://segmentfault.com/a/1190000009956880

```
String：String / StringBuffer / StringBuilder 三者的功能区别

String 作为最基础的引用数据类型，日常的开发中被大量的使用。基于不可变的特性，一旦被过度地使用，堆内存就会负荷不堪，甚至影响性能，为此，Java 设计者特意为 String 在方法区中开辟了字符串常量池，以减少 String 的实例创建，然而，在面对大数量的情况下，字符串常量池也未必能解决问题，因此，AbstractStringBuilder 应运而生，就是为了解决 String频繁创建而引发的内存性能下降的问题。

带着两个问题，去看看String / StringBuffer / StringBuilder 的区别

String vs AbstractStringBuilder

StringBuffer vs StringBuilder

String / StringBuffer / StringBuilder 的使用策略

String vs AbstractStringBuilder
扩容机制

String

不可变性:重新创建一个对象

String 底层代码实现：

String 类被 final 修饰，该类不能被继承

value[] 属性 被final 修饰 ，引用不能修改

public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];   ／／

    /** Cache the hash code for the string */
    private int hash; // Default to 0```
    
    //other codes
测试代码:



 String str = new String("a");
        str = str  + “b” ;
图示:

图片描述

AbstractStringBuilder

可变性

AbstractStringBuilder 底层代码实现：

value[] 相对于 String ，没有被final修饰

append("String") 返回时对象本身，不会创建新的对象

abstract class AbstractStringBuilder implements Appendable, CharSequence {
     /**
     * The value is used for character storage.
     */
    char[] value;

    /**
     * The count is the number of characters used.
     */
    int count;
    
    
    // other codes 
    
    
    public AbstractStringBuilder append(String str) {
        if (str == null)
            return appendNull();
        int len = str.length();
        ensureCapacityInternal(count + len);
        str.getChars(0, len, value, count);
        count += len;
        return this;
    }
    
    //other codes
}
测试代码：

  StringBuffer sb = new StringBuffer("a");
               sb.append("b");
图示：
图片描述

性能比较

public class StringBufferWithStringBuilder {

    public void testString() {
        long start = System.currentTimeMillis();
        String str = null;
        for (int i = 0; i < 20000; i++) {
            str = str + i + ",";
        }
        System.out.println(System.currentTimeMillis() - start); 
    }

    public void testStringBuffer() {
        long start = System.currentTimeMillis();

        StringBuffer sbuf = new StringBuffer();
        for (int i = 0; i < 20000; i++) {
            sbuf.append(i + ",");
        }
        System.out.println(System.currentTimeMillis() - start);
    }

    public void testStringBulider() {
        long start = System.currentTimeMillis();

        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < 20000; i++) {
            builder.append(i + ",");
        }
        System.out.println(System.currentTimeMillis() - start);
    }

    @Test
    public void test(){
        testString();
        testStringBuffer();
        testStringBulider();
    }
    
}
通过测试数据得知，在性能和效率上：StringBuilder>StringBuffer>String

原因在于：

String 每执行一次 + 重载运算符，必须创建一个新的对象

StringBuilder 与 StringBuffer相比，少了同步锁

StringBuffer vs StringBuilder
线程安全

StringBuffer 是线程安全的

StringBuilder 是线程不安全

底层实现： StringBuffer 通过 synchronized 关键字的修饰，保证了资源不会被抢占，从而确保了线程安全

 /**
     * @since      1.5
     */
    @Override
    public synchronized void trimToSize() {
        super.trimToSize();
    }

    /**
     * @throws IndexOutOfBoundsException {@inheritDoc}
     * @see        #length()
     */
    @Override
    public synchronized void setLength(int newLength) {
        toStringCache = null;
        super.setLength(newLength);
    }
String / StringBuffer / StringBuilder 的使用策略
基本原则：如果要操作少量的数据，用String ；单线程操作大量数据，用StringBuilder ；多线程操作大量数据，用StringBuffer

不要使用String类的"+"来进行频繁的拼接，因为那样的性能极差的，应该使用StringBuffer或StringBuilder类，这在Java的优化上是一条比较重要的原则

为了获得更好的性能，在构造 StringBuffer 或 StringBuilder 时应尽可能指定它们的容量。当然，如果你操作的字符串长度（length）不超过 16 个字符就不用了，当不指定容量（capacity）时默认构造一个容量为16的对象。不指定容量会显著降低性能

StringBuilder一般使用在方法内部来完成类似"+"功能，因为是线程不安全的，所以用完以后可以丢弃。StringBuffer主要用在全局变量中

相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。而在现实的模块化编程中，负责某一模块的程序员不一定能清晰地判断该模块是否会放入多线程的环境中运行，因此：除非确定系统的瓶颈是在 StringBuffer 上，并且确定你的模块不会运行在多线程模式下，才可以采用StringBuilder；否则还是用StringBuffer
```

#### 10.说说反射的用途及实现 

```
1、什么是Java类中的反射？
当程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言。我们认为 Java 并不是动态语言，但是它却又一个非常突出的动态相关的机制，俗称：反射。
Reflection 是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类和对象的内部属性。
通过反射，我们可以在运行时获得程序或程序集中每一个类型成员和成员变量的信息。
程序中一般的对象类型都是在编译期就确定下来的，而Java 反射机制可以动态的创建对象并调用其属性，这样对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象即使这个对象在编译期是未知的，
反射的核心：是 JVM 在运行时 才动态加载的类或调用方法或属性，他不需要事先（写代码的时候或编译期）知道运行对象是谁。 
2、Java反射框架提供以下功能：
①、在运行时判断任意一个对象所属的类
②、在运行时构造任意一个类的对象
③、在运行时判断任意一个类所具有的成员变量和方法（通过反射设置可以调用 private）
④、在运行时调用人一个对象的方法
3、反射的主要用途
很多人都认为反射在实际Java中开发应用中并不广泛，其实不然。
当我们在使用 IDE（如 Eclipse\IDEA）时，当我们输入一个队长或者类并向调用它的属性和方法时，一按 (“.”)点号，编译器就会自动列出她的属性或方法，这里就会用到反射。

反射最重要的用途就是开发各种通用框架。
很多框架（比如 Spring）都是配置化的（比如通过 XML文件配置 JavaBean，Action之类的），为了保证框架的通用性，他们可能根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。
举一个例子，在运用Struts 2框架的开发中我们一般会在struts.xml里去配置Action，比如：

<action name="login"
           class="org.ScZyhSoft.test.action.SimpleLoginAction"
           method="execute">
       <result>/shop/shop-index.jsp</result>
       <result name="error">login.jsp</result>
   </action>
配置文件与Action建立了一种映射关系，当View层发出请求时，请求会被StrutsPrepareAndExecuteFilter拦截，然后StrutsPrepareAndExecuteFilter会去动态地创建Action实例。
——比如我们请求login.action，那么StrutsPrepareAndExecuteFilter就会去解析struts.xml文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。
对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。

4、反射的基本运用
以上我们提到了反射可以拟用于判断任意对象所属的类，获得 Class对象，构造人一个对象以及调用一个对象。这里我们介绍一下基本反射功能的事先（反射相关类一般都在 java.lang.relfect包里）。

①、获得 Class 对象

（1）、使用 Class类的 forName() 静态方法：
public static Class<?> forName(String className)
……
在JDBC开发中常用此方法加载数据库驱动:
……java
Class.forName(driver)
（2）、直接获取某一个对象的 class，比如：
Class<?> klass = int.class;
Class<?> classInt = Integer.TYPE;
（3）、调用某个对象的getClass() 方法，比如：
StringBuilder str = new StringBuilder("123");
Class<?> klass = str.getClass();

②、判断是否为某个类的实例

一般地，我们用 instanceof关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的 isInstance()方法来判断是否为某个类的实例，它是一个 Native 方法：

  public native boolean isInstance(Object obj);
③、创建实例

通过反射来生成对象主要有两种方式。
（1）使用 Class 对象的 newInstance() 方法来创建对象对应类的实例。

Class<?> c  = String.calss;
Object str = c.getInstance();
（2）、先通过 Class 对象获取制定的 Constructor 对象，在调用 Constructor 对象的 newInstance() 方法来创建实例。这种方法可以用指定的构造器构造类的实例。

  //获取String所对应的Class对象
   Class<?> c = String.class;
  //获取String类带一个String参数的构造器
  Constructor constructor = c.getConstructor(String.class);
  //根据构造器创建实例
  Object obj = constructor.newInstance("23333");
  System.out.println(obj);
```

#### 11.说说自定义注解的场景及实现 

```
1. Java自定义注解与Spring
Java注解作为程序元素（类、成员变量、成员方法等）的一种元数据信息，对程序本身的执行不会产生影响。通过自定义注解，可以给程序元素添加特殊的声明。

Spring作为构建企业级应用的平台，提供了丰富的功能。将Java的自定义注解与Spring结合，在特定场景下实现注解的解析、处理，可以降低应用的耦合度，提高程序的可扩展性。

2. 应用场景
下面总结几种应用场景，仅说明大致思路（ps：并非所有场景都在项目中实践过）

2.1 登陆、权限拦截
在web项目中，登陆拦截和权限拦截是一个老生常谈的功能。通过自定义登陆注解或权限注解，在自定义拦截器中解析注解，实现登陆和权限的拦截功能。

这种使用方式，配置简单，灵活度高，代码耦合度低。

2.2 定时任务管理
在系统构建过程中，会有各种定时任务的需求，而定时任务的集中管理，可以更高效维护系统的运行。

通过Java注解官方文档Repeating Annotations章节中的自定义的定时任务注解，可以实现业务方法的定时任务声明。结合Spring的容器后处理器BeanPostProcessor（ps：Spring容器后处理器下篇再说），解析自定义注解。解析后的注解信息再使用Quartz API构建运行时定时任务，即可完成定时任务的运行时创建和集中管理。

这种方式能避免定义Quartz定时任务的配置，提高系统扩展性。

2.3 多数据源路由的数据源指定
Spring提供的AbstractRoutingDataSource实现多数据源的动态路由，可应用在主从分离的架构下。通过对不同的方法指定不同的数据源，实现数据源的动态路由（例如：读方法走从库数据源，写方法走主库数据源）。而如何标识不同的方法对应的数据源类型，则可使用自定义注解实现。通过解析方法上声明的自定义注解对应的数据源类型，实现数据源的路由功能。

注解实战：
1.能够读懂别人写的代码，特别是框架相关的代码。



2.本来可能需要很多配置文件，需要很多逻辑才能实现的内容，就可以使用一个或者多个注解来替代，这样就使得编程更加简洁，代码更加清晰。



3.（重点）刮目相看。



（但是怎么样才能让别人刮目相看呢？会用注解不是目的，最重要的是要使用自定义注解来解决问题。）



举个栗子：



如果面试的时候，你跟老板说你会使用注解，老板觉得你这个人还行；但是如果老板发现你会自定义注解解决问题，老板肯定就会眼前一亮。



注解这一概念是在java1.5版本提出的，说Java提供了一种原程序中的元素关联任何信息和任何元数据的途径的方法。



一、Java中的常见注解



1）JDK注解



JDK注解一共分为三类：







案例：



我们先新建一个接口people，如下：



public interface people {

    public String name();

    public int age();

    public void work();

}



然后再建一个类Child实现类people这个接口，并实现该类的方法：



public class Child implements people {

    @Override

    public String name() {

        return null;

    }



    @Override

    public int age() {

        return 0;

    }



    @Override

    public void work() {



    }



看到这里，我们发现这里的所有方法都会加上一个@Override标记，它告诉我们，同时也告诉编译器我们的这些方法肯定覆盖了类people里面的方法的。假如说，我现在把类people里面的某一个方法注释掉：



//public String name();



再看类Child里面的name方法就会报错。这样，以后大家看到@Override的时候就能想到这个方法是覆盖了某个接口的方法的。



然后，我们回过头来看类people里面有一个work的方法。这里我们可以理解为人是要工作的，但是并不是所有的人都在工作，那么怎么办呢？如果说这个接口正在用，我们不能删除这个方法，这个时候我们就可以这样：



@Deprecated

public void work();



@Deprecated标记就表明这个方法已经过时了，在实际中，它又有什么样的应用场景呢？我们在建一个测试类：



public class Test {

    public void work() {

        people people=new Child();

！        people.work();

    }

}



这个时候我们会发现myeclipse会给一个警告，并且在work中间出现一个破折号，意思就是这个方法已经过时了。那么问题来了，虽然这个方法过时了，但是我们就是那么傲娇，一定要用它，怎么办呢？只需要这样：



public class Test {

    @SuppressWarnings("deprecation")

    public void work() {

        people people=new Child();

        people.work();

    }

}



这样我们就忽略了这个警告。@SuppressWarnings(“deprecation”)就表示我们忽略了deprecation这样的一个警告。



2）Java第三方注解









二、注解的分类



1）按照运行机制划分：



【源码注解→编译时注解→运行时注解】



源码注解：只在源码中存在，编译成.class文件就不存在了。



编译时注解：在源码和.class文件中都存在。像前面的@Override、@Deprecated、@SuppressWarnings，他们都属于编译时注解。



运行时注解：在运行阶段还起作用，甚至会影响运行逻辑的注解。像@Autowired自动注入的这样一种注解就属于运行时注解，它会在程序运行的时候把你的成员变量自动的注入进来。



2）按照来源划分：



【来自JDK的注解——来自第三方的注解——自定义注解】



3）元注解：



元注解是给注解进行注解，可以理解为注解的注解就是元注解。



三、自定义注解



我们分四步来解析自定义注解：

自定义注解的语法要求：



@Target({ElementType.METHOD,ElementType.TYPE})

@Retention(RetentionPolicy.RUNTIME)

@Inherited

@Documented

public @interface Description {

    String desc();

    String author();

    int age() default 18;

}



首先我们要明确这不是一个接口，它是使用@interface关键字定义的一个注解。



然后我们看下面的几个方法，String desc();虽然它很类似于接口里面的方法，其实它在注解里面只是一个成员变量（成员以无参无异常的方式声明），int age() default 18;（成员变量可以用default指定一个默认值的）。



最后我们要知道：



①.成员类型是受限制的，合法的类型包括基本的数据类型以及String，Class，Annotation,Enumeration等。



②.如果注解只有一个成员，则成员名必须取名为value()，在使用时可以忽略成员名和赋值号（=）。



③.注解类可以没有成员，没有成员的注解称为标识注解。



元注解：



有没有发现上面那段代码有一个没有说呢？没错，它们就是我们所说的元注解：



@Target({ElementType.METHOD,ElementType.TYPE})

@Retention(RetentionPolicy.RUNTIME)

@Inherited

@Documented



我们先看第一行：@Target是这个注解的作用域，ElementType.METHOD是这个注解的作用域的列表，METHOD是方法声明，除此之外，还有：



CONSTRUCTOR（构造方法声明）,FIELD（字段声明）,LOCAL VARIABLE（局部变量声明）,METHOD（方法声明）,PACKAGE（包声明）,PARAMETER（参数声明）,TYPE（类接口）



第二行：@Retention是它的生命周期，前面不是说注解按照运行机制有一个分类嘛，RUNTIME就是在运行时存在，可以通过反射读取。除此之外，还有:



SOURCE（只在源码显示，编译时丢弃）,CLASS（编译时记录到class中，运行时忽略）,RUNTIME（运行时存在，可以通过反射读取）



第三行：@Inherited是一个标识性的元注解，它允许子注解继承它。



第四行：@Documented，生成javadoc时会包含注解。



使用自定义注解：

使用注解的语法：



@<注解名>(<成员名1>=<成员值1>,<成员名1>=<成员值1>,…)



案例：



@Description(desc="i am Color",author="boy",age=18)

public String Color() {

    return "red";

}



这里的Description是我们刚才在自定义注解语法要求里面定义的注解噢，然后我们可以给它的每一个成员变量赋值，注意数据类型。值得注意的是，因为我们前面定义的作用域是在方法和类接口上，所以这个注解在Color()方法上使用是没问题的。



解析注解



概念：

通过反射获取类 、函数或成员上的运行时注解信息，从而实现动态控制程序运行的逻辑。



准备工作：







接下来，我们就开始测试了：



public class ParseAnn {

    public static void main(String[] args) {

        try {

            // 使用类加载器加载类

            Class c = Class.forName("com.test.Child");

            // 找到类上面的注解

            boolean isExist = c.isAnnotationPresent(Description.class);

            // 上面的这个方法是用这个类来判断这个类是否存在Description这样的一个注解

            if (isExist) {

                // 拿到注解实例，解析类上面的注解

                Description d = (Description) c.getAnnotation(Description.class);

                System.out.println(d.value());

            }

        } catch (ClassNotFoundException e) {

            e.printStackTrace();

        }

    }

}



输出的结果：



i am class annotation



可以看到，我们成功的解析了Child类上面的注解。



接下来，我们继续解析方法上的注解：



//获取所有的方法

Method[] ms = c.getMethods();

// 遍历所有的方法

for (Method m : ms) {

    boolean isExist1 = m.isAnnotationPresent(Description.class);

    if (isExist1) {

        Description d1=m.getAnnotation(Description.class);

        System.out.println(d1.value());

    }

}



输出的结果：



i am class annotation

i am method annotation



可以看到，我们成功的解析了方法上面的注解。



//另一种解析方法

for (Method m : ms) {

    //拿到方法上的所有的注解

    Annotation[] as=m.getAnnotations();

    for (Annotation a : as) {

        //用二元操作符判断a是否是Description的实例

        if (a instanceof Description) {

            Description d=(Description) a;

            System.out.println(d.value());

        }

    }

}



也可以得到上面的效果。



此时，如果把Description类里面的元注解改一下，比如:



@Retention(RetentionPolicy.RUNTIME)→@Retention(RetentionPolicy.SOURCE)，再运行程序，结果会成怎样呢？如果改成CLASS呢？读者们要不要试一试？



如果看过我写的《谈谈JAVA反射机制》——Class类的动态加载的读者，仔细想一下我们这个环境，就知道为什么了。


```

#### 12.HTTP请求的GET与POST方式的区别 

![img](C:\Users\13441\Desktop\md\做过的面试题\做过的面试题.assets\640)

 

```
（差别一）GET后退按钮/刷新无害，POST数据会被重新提交（浏览器应该告知用户数据会被重新提交）。

（差别二）GET书签可收藏，POST为书签不可收藏。GET能被缓存，POST不能缓存 。GET编码类型application/x-www-form-url，POST编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。

（差别三）GET历史参数保留在浏览器历史中。POST参数不会保存在浏览器历史中。

（差别四）GET对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST无限制。

（差别五）GET只允许 ASCII 字符。POST没有限制。也允许二进制数据。

（差别六）与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。GET的数据在 URL 中对所有人都是可见的。POST的数据不会显示在 URL 中。
```

#### 13.幂等性

[互联网后端架构](javascript:void(0);) *2017-03-27*

理解HTTP幂等性

基于HTTP协议的Web API是时下最为流行的一种分布式服务提供方式。无论是在大型互联网应用还是企业级架构中，我们都见到了越来越多的SOA或RESTful的Web API。为什么Web API如此流行呢？我认为很大程度上应归功于简单有效的HTTP协议。HTTP协议是一种分布式的面向资源的网络应用层协议，无论是服务器端提供Web服务，还是客户端消费Web服务都非常简单。再加上浏览器、Javascript、AJAX、JSON以及HTML5等技术和工具的发展，互联网应用架构设计表现出了从传统的PHP、JSP、ASP.NET等服务器端动态网页向Web API + RIA（富互联网应用）过渡的趋势。Web API专注于提供业务服务，RIA专注于用户界面和交互设计，从此两个领域的分工更加明晰。在这种趋势下，Web API设计将成为服务器端程序员的必修课。然而，正如简单的Java语言并不意味着高质量的Java程序，简单的HTTP协议也不意味着高质量的Web API。要想设计出高质量的Web API，还需要深入理解分布式系统及HTTP协议的特性。

##### 幂等性定义

本文所要探讨的正是HTTP协议涉及到的一种重要性质：幂等性(Idempotence)。在HTTP/1.1规范中幂等性的定义是：

> Methods can also have the property of "idempotence" in that (aside from error or expiration issues) the side-effects of N > 0 identical requests is the same as for a single request.

从定义上看，HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。幂等性属于语义范畴，正如编译器只能帮助检查语法错误一样，HTTP规范也没有办法通过消息格式等语法手段来定义它，这可能是它不太受到重视的原因之一。但实际上，幂等性是分布式系统设计中十分重要的概念，而HTTP的分布式本质也决定了它在HTTP中具有重要地位。

##### 分布式事务 vs 幂等设计

为什么需要幂等性呢？我们先从一个例子说起，假设有一个从账户取钱的远程API（可以是HTTP的，也可以不是），我们暂时用类函数的方式记为： 

```
bool withdraw(account_id, amount)
```

withdraw的语义是从account_id对应的账户中扣除amount数额的钱；如果扣除成功则返回true，账户余额减少amount；如果扣除失败则返回false，账户余额不变。值得注意的是：和本地环境相比，我们不能轻易假设分布式环境的可靠性。一种典型的情况是withdraw请求已经被服务器端正确处理，但服务器端的返回结果由于网络等原因被掉丢了，导致客户端无法得知处理结果。如果是在网页上，一些不恰当的设计可能会使用户认为上一次操作失败了，然后刷新页面，这就导致了withdraw被调用两次，账户也被多扣了一次钱。如图1所示：

![img](C:\Users\13441\Desktop\md\做过的面试题\做过的面试题.assets\640-1526194003610)

图1

这个问题的解决方案一是采用分布式事务，通过引入支持分布式事务的中间件来保证withdraw功能的事务性。分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，而但却无法提供性能和可用性的保证。

另一种更轻量级的解决方案是幂等设计。我们可以通过一些技巧把withdraw变成幂等的，比如：

```
int create_ticket() 
bool idempotent_withdraw(ticket_id, account_id, amount)
```

create_ticket的语义是获取一个服务器端生成的唯一的处理号ticket_id，它将用于标识后续的操作。idempotent_withdraw和withdraw的区别在于关联了一个ticket_id，一个ticket_id表示的操作至多只会被处理一次，每次调用都将返回第一次调用时的处理结果。这样，idempotent_withdraw就符合幂等性了，客户端就可以放心地多次调用。

基于幂等性的解决方案中一个完整的取钱流程被分解成了两个步骤：1.调用create_ticket()获取ticket_id；2.调用idempotent_withdraw(ticket_id, account_id, amount)。虽然create_ticket不是幂等的，但在这种设计下，它对系统状态的影响可以忽略，加上idempotent_withdraw是幂等的，所以任何一步由于网络等原因失败或超时，客户端都可以重试，直到获得结果。如图2所示：

![img](C:\Users\13441\Desktop\md\做过的面试题\做过的面试题.assets\640-1526193997240)

图2

和分布式事务相比，幂等设计的优势在于它的轻量级，容易适应异构环境，以及性能和可用性方面。在某些性能要求比较高的应用，幂等设计往往是唯一的选择。

##### HTTP的幂等性

HTTP协议本身是一种面向资源的应用层协议，但对HTTP协议的使用实际上存在着两种不同的方式：一种是RESTful的，它把HTTP当成应用层协议，比较忠实地遵守了HTTP协议的各种规定；另一种是SOA的，它并没有完全把HTTP当成应用层协议，而是把HTTP协议作为了传输层协议，然后在HTTP之上建立了自己的应用层协议。本文所讨论的HTTP幂等性主要针对RESTful风格的，不过正如上一节所看到的那样，幂等性并不属于特定的协议，它是分布式系统的一种特性；所以，不论是SOA还是RESTful的Web API设计都应该考虑幂等性。下面将介绍HTTP GET、DELETE、PUT、POST四种主要方法的语义和幂等性。

HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。比如：GET http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。

HTTP DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：DELETE http://www.forum.com/article/4231，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。

比较容易混淆的是HTTP POST和PUT。POST和PUT的区别容易被简单地误认为“POST表示创建资源，PUT表示更新资源”；而实际上，二者均可用于创建资源，更为本质的差别是在幂等性方面。在HTTP规范中对POST和PUT是这样定义的：

> The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line ...... If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header.
> The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.

POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。而PUT所对应的URI是要创建或更新的资源本身。比如：PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。

在介绍了几种操作的语义和幂等性之后，我们来看看如何通过Web API的形式实现前面所提到的取款功能。很简单，用POST /tickets来实现create_ticket；用PUT /accounts/account_id/ticket_id&amount=xxx来实现idempotent_withdraw。值得注意的是严格来讲amount参数不应该作为URI的一部分，真正的URI应该是/accounts/account_id/ticket_id，而amount应该放在请求的body中。这种模式可以应用于很多场合，比如：论坛网站中防止意外的重复发帖。

##### 总结

上面简单介绍了幂等性的概念，用幂等设计取代分布式事务的方法，以及HTTP主要方法的语义和幂等性特征。

#### 14.Session与Cookie区别 

```
Cookie与Session的区别
java那些事  2016-02-19

　本文分别对Cookie与Session做一个介绍和总结，并分别对两个知识点进行对比分析，让大家对Cookie和Session有一个更深入的了解，并对自己的开发工作中灵活运用带来启示。
　cookie机制
　　Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。IETF RFC 2965 HTTP State Management Mechanism 是通用cookie规范。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies。

　　具体来说cookie机制采用的是在客户端保持状态的方案。它是在用户端的会话状态的存贮机制，他需要用户打开客户端的cookie支持。cookie的作用就是为了解决HTTP协议无状态的缺陷所作的努力。

　　正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。

　　cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。

　　而session机制采用的是一种在服务器端保持状态的解决方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的。而session提供了方便管理全局变量的方式。

　　session是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器。

　　就安全性来说：当你访问一个使用session 
的站点，同时在自己机子上建立一个cookie，建议在服务器端的session机制更安全些，因为它不会任意读取客户存储的信息。

　session机制
　　session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。

　　当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。

　　保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。

　　经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。

　　Cookie与Session都能够进行会话跟踪，但是完成的原理不太一样。普通状况下二者均能够满足需求，但有时分不能够运用Cookie，有时分不能够运用Session。下面经过比拟阐明二者的特性以及适用的场所。

　　1 .存取方式的不同

　　Cookie中只能保管ASCII字符串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取Java对象。若要存储略微复杂的信息，运用Cookie是比拟艰难的。

　　而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。Session中也能够直接保管Java Bean乃至任何Java类，对象等，运用起来十分便当。能够把Session看做是一个Java容器类。

　　2 .隐私策略的不同

　　Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。

　　假如选用Cookie，比较好的方法是，敏感的信息如账号密码等尽量不要写到Cookie中。最好是像Google、Baidu那样将Cookie信息加密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。而假如选择Session就省事多了，反正是放在服务器上，Session里任何隐私都能够有效的保护。

　　3.有效期上的不同

　　使用过Google的人都晓得，假如登录过Google，则Google的登录信息长期有效。用户不用每次访问都重新登录，Google会持久地记载该用户的登录信息。要到达这种效果，运用Cookie会是比较好的选择。只需要设置Cookie的过期时间属性为一个很大很大的数字。

　　由于Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默许为–1，只需关闭了阅读器该Session就会失效，因而Session不能完成信息永世有效的效果。运用URL地址重写也不能完成。而且假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。

　　4.服务器压力的不同

　　Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。因而像Google、Baidu、Sina这样并发访问量极高的网站，是不太可能运用Session来追踪客户会话的。

　　而Cookie保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie是很好的选择。关于Google、Baidu、Sina来说，Cookie或许是唯一的选择。

　　5 .浏览器支持的不同

　　Cookie是需要客户端浏览器支持的。假如客户端禁用了Cookie，或者不支持Cookie，则会话跟踪会失效。关于WAP上的应用，常规的Cookie就派不上用场了。

　　假如客户端浏览器不支持Cookie，需要运用Session以及URL地址重写。需要注意的是一切的用到Session程序的URL都要进行URL地址重写，否则Session会话跟踪还会失效。关于WAP应用来说，Session+URL地址重写或许是它唯一的选择。

　　假如客户端支持Cookie，则Cookie既能够设为本浏览器窗口以及子窗口内有效（把过期时间设为–1），也能够设为一切阅读器窗口内有效（把过期时间设为某个大于0的整数）。但Session只能在本阅读器窗口以及其子窗口内有效。假如两个浏览器窗口互不相干，它们将运用两个不同的Session。（IE8下不同窗口Session相干）

　　6.跨域支持上的不同

　　Cookie支持跨域名访问，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。

　　仅运用Cookie或者仅运用Session可能完成不了理想的效果。这时应该尝试一下同时运用Cookie与Session。Cookie与Session的搭配运用在实践项目中会完成很多意想不到的效果。

　　via：http://www.lai18.com/content/407204.html



```

#### 15.列出自己常用的JDK包 

```
1、java.lang
包含一些 Java 语言的核心类

2、java.sql
提供使用Java TM编程语言访问和处理存储在数据源（通常是关系数据库）中的数据的API。

3、java.io
包含能提供多种输入/输出功能的类.File 文件和目录路径名的抽象表示。  FileInputStream A FileInputStream从文件系统中的文件获取输入字节。 FileOutputStream 文件输出流是用于将数据写入到输出流 File或一个 FileDescriptor 。  Reader 用于读取字符流的抽象类。  Writer 用于写入字符流的抽象类。  

4、java.math
封装最常用的数学方法，如正弦、余弦和平方根

5、java.text
提供用于以独立于自然语言的方式处理文本，日期，数字和消息的类和接口。 Format是用于格式化区域设置敏感信息（如日期，消息和数字）的抽象基类.

6、java.net
java.net—-包含执行与网络相关的操作的类，如 URL, Socket, ServerSocket 等。
HttpCookie HttpCookie对象表示HTTP cookie，它承载服务器和用户代理之间的状态信息。  Socket 该类实现客户端套接字（也称为“套接字”）。  ServerSocket 这个类实现了服务器套接字 

7、java.util
包含一些实用工具类，如定义系统特性、使用与日期日历相关的方法,java.util.jar,java.util.regex匹配字符序列与正则表达式指定的模式的类。 java.util.zip提供读写标准ZIP和GZIP文件格式的类。

8、java.awt，java.swing
包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。
完全 Java 版的图形用户界面(GUI)解决方案，提供了很多完备的组件，可以应对复杂的桌面系统构建。
9、 java.time
日期，时间，瞬间和持续时间的主要API。 Clock 使用时区提供对当前即时，日期和时间的访问的时钟。  LocalDate 在ISO- 2007-12-03 ，如 2007-12-03 。  
```

#### 16.MVC设计思想 

```
MVC英文即Model-View-Controller，即把一个应用的输入、处理、输出流程按照Model、View、Controller的方式进行分离，这样一个应用被分成三个层——模型层、视图层、控制层。 

　　视图(View)代表用户交互界面，对于Web应用来说，可以概括为HTML界面，但有可能为XHTML、XML和Applet。随着应用的复杂性和规模性，界面的处理也变得具有挑战性。一个应用可能有很多不同的视图，MVC设计模式对于视图的处理仅限于视图上数据的采集和处理，以及用户的请求，而不包括在视图上的业务流程的处理。业务流程的处理交予模型(Model)处理。比如一个订单的视图只接受来自模型的数据并显示给用户，以及将用户界面的输入数据和请求传递给控制和模型。 

　　模型(Model)：就是业务流程/状态的处理以及业务规则的制定。业务流程的处理过程对其它层来说是黑箱操作，模型接受视图请求的数据，并返回最终的处理结果。业务模型的设计可以说是MVC最主要的核心。目前流行的EJB模型就是一个典型的应用例子，它从应用技术实现的角度对模型做了进一步的划分，以便充分利用现有的组件，但它不能作为应用设计模型的框架。它仅仅告诉你按这种模型设计就可以利用某些技术组件，从而减少了技术上的困难。对一个开发者来说，就可以专注于业务模型的设计。MVC设计模式告诉我们，把应用的模型按一定的规则抽取出来，抽取的层次很重要，这也是判断开发人员是否优秀的设计依据。抽象与具体不能隔得太远，也不能太近。MVC并没有提供模型的设计方法，而只告诉你应该组织管理这些模型，以便于模型的重构和提高重用性。我们可以用对象编程来做比喻，MVC定义了一个顶级类，告诉它的子类你只能做这些，但没法限制你能做这些。这点对编程的开发人员非常重要。 

　　业务模型还有一个很重要的模型那就是数据模型。数据模型主要指实体对象的数据 保存（持续化）。比如将一张订单保存到数据库，从数据库获取订单。我们可以将这个模型单独列出，所有有关数据库的操作只限制在该模型中。 

　　控制(Controller)可以理解为从用户接收请求, 将模型与视图匹配在一起，共同完成用户的请求。划分控制层的作用也很明显，它清楚地告诉你，它就是一个分发器，选择什么样的模型，选择什么样的视图，可以完成什么样的用户请求。控制层并不做任何的数据处理。例如，用户点击一个连接，控制层接受请求后, 并不处理业务信息，它只把用户的信息传递给模型，告诉模型做什么，选择符合要求的视图返回给用户。因此，一个模型可能对应多个视图，一个视图可能对应多个模型。 
```

#### 17.equals与==的区别

```
==与equals的主要区别是：==常用于比较原生类型，而equals()方法用于检查对象的相等性。另一个不同的点是：如果==和equals()用于比较对象，当两个引用地址相同，==返回true。而equals()可以返回true或者false主要取决于重写实现。最常见的一个例子，字符串的比较，不同情况==和equals()返回不同的结果。equals()方法最重要的一点是，能够根据业务要求去重写，按照自定义规则去判断两个对象是否相等。重写equals()方法的时候，要注意一下hashCode是否会因为对象的属性改变而改变，否则在使用散列集合储存该对象的时候会碰到坑！！理解equals()方法的存在是很重要的。
使用==比较有两种情况：
```

#### 18.hashCode和equals方法的区别与联系 

```
equals方法比较清楚，字面意思就是用来进行比较。Hashcode方法用来计算当前对象的Hash值，这个值直白的讲就是用来和其它对象做区分，理论上每个对象都有一个唯一的Hash值，但实际上也有重复的，但是重复的比较概率比较小而已。我们要对两个对象进行比较，离不开这两个方法的正确定义，这两个方法如果理解不透彻，定义不合理，则会导致对象无法进行正确的比较。
对于Object对象来说，不同的Object对象的hashcode是不同的，它们返回的是对象的地址，equals方法返回的也是对象的地址。所以在自己定义的类中如果要添加到集合对象中，最好是重写hashcode和equals方法，不然会自动继承自Object类中的两个方法而使用对象地址来判断，这样做并不合理。
重写Object类的equals()方法的同时为什必须覆盖hashCode()方法？

因为java的collection很多都需要hashCode()，例如HashTable。

比如说你往里面存了一个值，你在取这个值的时候，java实际上通过hashCode()来找那个值，因为这样通常比较快。如果你覆盖了equals()方法，意味着原来不相等的两个对象现在可能变得相等，但hashCode()的值却不相等，这样你使用HashTable就会出现存进去的东西找不到的问题。千万不要忽略这个问题，因为HashTable等容器类用的非常多，很可能就在一个你不知道的地方间接地用到了。java类的一个原则就是：你定义的任何类，都要考虑覆盖equals和hashCode方法。否则你的类就不能给其他人或其他地方用。

hashCode()的返回值和equals()的关系如下：
如果x.equals(y)返回“true”，那么x和y的hashCode()必须相等。
如果x.equals(y)返回“false”，那么x和y的hashCode()有可能相等，也有可能不等。
```

#### 19.什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用 

```
首先要明确序列化的目的：

    1.无论何种类型的数据，都是以二进制的形式在网络上传送，为了由一个进程把Java对象发送给另一个进程，需要把其转换为字节序列才能在网络上传送，把JAVA对象转换为字节序列的过程就称为对象的序列化，将字节序列恢复成Java对象的过程称为对象的反序列化，（然后java.io.ObjectOutPutStream的writeObject(Object obj)的方法就可以 将参数指定的对象进行序列化 并且把得到的字节流写到一个目标输出流上去）
    首先要明确序列化的目的：

    1.无论何种类型的数据，都是以二进制的形式在网络上传送，为了由一个进程把Java对象发送给另一个进程，需要把其转换为字节序列才能在网络上传送，把JAVA对象转换为字节序列的过程就称为对象的序列化，将字节序列恢复成Java对象的过程称为对象的反序列化，（然后java.io.ObjectOutPutStream的writeObject(Object obj)的方法就可以 将参数指定的对象进行序列化 并且把得到的字节流写到一个目标输出流上去）



2.只有实现了 serializable和Externalizable接口的类的对象才能被序列化  后者是前者的子类   实现这个借口的类完全由自身来控制序列化的行为，而仅仅实现前者的类可以采用默认的序列化方式。实现这两个接口 标志着对象可以被序列化了。。。
摘要
Java 串行化技术可以使你将一个对象的状态写入一个Byte 流里，并且可以从其它地方把该Byte 流里的数据读出来，重新构造一个相同的对象。
Java 串行化技术可以使你将一个对象的状态写入一个Byte 流里，并且可以从其它地方把该Byte 流里的数据读出来，重新构造一个相同的对象。这种机制允许你将对象通过网络进行传播，并可以随时把对象持久化到数据库、文件等系统里。Java的串行化机制是RMI、EJB等技术的技术基础。用途：利用对象的串行化实现保存应用程序的当前工作状态，下次再启动的时候将自动地恢复到上次执行的状态。

序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。

序列化的实现：将需要被序列化的类实现Serializable接口，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。

2、串行化的特点：

    （1）如果某个类能够被串行化，其子类也可以被串行化。如果该类有父类，则分两种情况来考虑，如果该父类已经实现了可串行化接口。则其父类的相应字段及属性的处理和该类相同；如果该类的父类没有实现可串行化接口，则该类的父类所有的字段属性将不会串行化。

  （2）声明为static和transient类型的成员数据不能被串行化。因为static代表类的状态， transient代表对象的临时数据；

  （3）相关的类和接口：在java.io包中提供的涉及对象的串行化的类与接口有ObjectOutput接口、ObjectOutputStream类、ObjectInput接口、ObjectInputStream类。

    （1）ObjectOutput接口：它继承DataOutput接口并且支持对象的串行化，其内的writeObject()方法实现存储一个对象。ObjectInput接口：它继承DataInput接口并且支持对象的串行化，其内的readObject()方法实现读取一个对象。

    （2）ObjectOutputStream类：它继承OutputStream类并且实现ObjectOutput接口。利用该类来实现将对象存储（调用ObjectOutput接口中的writeObject()方法）。ObjectInputStream类：它继承InputStream类并且实现ObjectInput接口。利用该类来实现读取一个对象（调用ObjectInput接口中的readObject()方法）。

  对于父类的处理，如果父类没有实现串行化接口，则其必须有默认的构造函数（即没有参数的构造函数）。否则编译的时候就会报错。在反串行化的时候，默认构造函数会被调用。但是若把父类标记为可以串行化，则在反串行化的时候，其默认构造函数不会被调用。这是为什么呢？这是因为Java 对串行化的对象进行反串行化的时候，直接从流里获取其对象数据来生成一个对象实例，而不是通过其构造函数来完成。
```

#### 20.Object类中常见的方法，为什么wait  notify会放在Object里边？ 

```
Object类中常见的方法：
getClass()
  返回此Object的运行时类。 返回的类对象是被表示类的static synchronized方法锁定的对象。
public int hashCode()
  返回对象的哈希码值。
public boolean equals(Object obj)
  指示一些其他对象是否等于此。 
  equals方法在非空对象引用上实现等价关系： 
  自反性 ：对于任何非空的参考值x ， x.equals(x)应该返回true 。 
  它是对称的 ：对于任何非空引用值x和y ， x.equals(y)应该返回true当且仅当y.equals(x)回报true 。 
  传递性 ：对于任何非空引用值x ， y和z ，如果x.equals(y)回报true个y.equals(z)回报true ，然后x.equals(z)应该返回true 。 
  它是一致的 ：对于任何非空引用值x和y ，多次调用x.equals(y)始终返回true或始终返回false ，没有设置中使用的信息equals比较上的对象被修改。 
  对于任何非空的参考值x ， x.equals(null)应该返回false 。 
protected void finalize()
                 throws Throwable
   当垃圾收集确定不再有对该对象的引用时，垃圾收集器在对象上调用该对象。 一个子类覆盖了处理系统资源或执行其他清理的finalize方法。
protected Object clone()
                throws CloneNotSupportedException
    创建并返回此对象的副本
public String toString()
		返回对象的字符串表示形式。 
wait()：  
        public final void wait(long timeout) throws InterruptedException  
        参数：等待的时间，可选，不填则默认为0。  
        说明：  
            1>使线程主动释放对象锁，并进入等待状态，直到它被其他线程通过notify()或notifyAll唤醒或者超过指定的等待时间。  
            2>在调用wait方法前，线程必须获得该对象的对象锁，即：只能在同步方法或同步代码块中调用wait方法，如果当前线程不是锁的持有者，将抛出一个IllegalMonitorStateException异常(是RuntimeException的子类，故不需要捕获)。  
            3>wait方法执行完成后，该线程立即释放持有的对象锁(注：不是等到退出synchronized代码块后才释放)。  
            4>this method should always be used in a loop: 
  notify()：  
        public final void notify()  
        说明：  
            1>随机选择一个在该对象上调用wait方法的线程，赋予其对象锁，解除其阻塞状态。  
            2>在执行notify()方法后，当前线程不会马上释放该对象锁，要等到执行notify()方法的线程退出synchronized方法或synchronized代码块后，当前线程才会释放锁，此时wait状态的线程才可以获取该对象锁，并继续执行synchronized代码块中wait()方法后面的代码。  
          
          
    notifyAll()：  
        public final void notifyAll()  
        说明：唤醒在该对象上调用wait方法等待的所有线程。  
          
  
    说明：wait()、notify()、notifyAll()这三个方法：  
        1)在调用方法前，线程必须获得该对象的对象锁，如果当前线程不是锁的持有者，方法将抛出一个IllegalMonitorStateException异常(是RuntimeException的子类，故不需要捕获)。  
        2)只能在非静态同步方法或非静态同步代码块内调用，而且必须由锁对象来调用方法：  
            1>这3个方法都是非静态方法，且这3个方法必须由锁对象调用，所以我们不能在静态同步方法和静态代码块中调用(静态同步方法的锁是类的Class锁)。  
            2>synchronized修饰的非静态方法：因为this就是锁对象，所以可以在同步方法中调用这三个方法(可以将this省略)。  
            3>synchronized修饰的非静态同步代码块：必须使用锁对象来调用这三个方法。  
        3)由于wait，notify和notifyAll都是锁级别的操作，而锁属于对象，故把他们定义在Object类中，而不是定义在Thread类中。
为什么wait，notify，notifyAll方法在Object队象中
        
	1.wait和notfiy它不并不是普通的方法，也不是像synchronized那样的关键字，它是线程间通讯的一种机制。放在Object class中是种好的选择。

   此外，当进入临界的代码时，线程需要被锁，它们也在等待锁的到来，但是它们不知道哪个线程正在持有锁，相反，它们只知道锁正在被某个线程占用，以及它们应该等待锁，

   而不是知道哪个线程在synchronized块中，让它们释放锁。

	2.锁面向于每个对象，这也是放在Object Class中的一个重要原因。
```

#### 21.Java的平台无关性如何体现出来的 

```
 体现：一次编写，到处运行。
 
 JAVA怎样保证它的平台无关性
 首先：对于JAVA程序设计语言规范来说，其用于计算的基本数据的位数，不依赖于其所处的平台。
  其次：对于JAVA平台，JAVA平台又称作JAVA运行时环境，是由JAVA虚拟机和JAVA API组成的，JAVA虚拟机负责加载和运行编译后的字节码，可以是标准的字节码，但是有的虚拟机也可以运行非标准的字节码。JAVA API负责与底层的操作系统平台进行交互，负责从平台中获取资源和与平台进行IO的交互，这样依赖，JAVA程序就只需要与JAVA虚拟机平台进行交互。
  同时，JAVA的这个平台还是具有可伸缩性的，这个平台可以嵌入到一些移动设备等硬件设备中运行，但是这些设备有可能存储空间非常有限，内存很小，这样就要求有一个最为紧凑的，消耗资源最少的平台，由于这些环境的特殊性，使得有一些JAVA API在这样的环境中完全用不到，所以就可以把这部分API去掉，并且有一部分的虚拟机的指令也是用不到的，所以也可以去到。这样，就形成了一个JAVA平台的最小集，即JME（Java Micro Edition），是一个非常微小的JAVA平台，形成了一个java的标准平台，JSE（Java Standard Edition），具有标准的JAVA API与指令集，有一个完全的平台，JEE（Java Enterprise Edition），java企业级应用的平台，包含了所有的JAVA API与指令集以及一些其他的标准，比如servlet和EJB等等。这样，Java平台就有很强的可伸缩性，能够适用于很多不同的硬件，这样，就保证了低端的平台可以向高端平台迁移，如果要做到平台的无关性，则需要注意，哪些API与指令集在一些平台中是不支持的。
  再次：对于java编译器来说，负责编译JAVA源文件，将JAVA文件编译成为对于对于java虚拟机可识别的独特的二进制的文件，它有固定的格式，能够被JAVA虚拟机的类加载子系统识别并加载。
```

#### 22.JDK和JRE的区别 

```
JDK是Java的开发工具，它不仅提供了Java程序运行所需的JRE，还提供了一系列的编译，运行等工具，如javac，java，javaw等。JRE只是Java程序的运行环境，它最核心的内容就是JVM（Java虚拟机）及核心类库。
```

#### 23.Java 8有哪些新特性 

```
1. 简介
毫无疑问，Java 8是Java自Java 5（发布于2004年）之后的最重要的版本。这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。在本文中我们将学习这些新特性，并用实际的例子说明在什么场景下适合使用。

这个教程包含Java开发者经常面对的几类问题：

语言
编译器
库
工具
运行时（JVM）
2. Java语言的新特性
2.1 Lambda表达式和函数式接口
2.2 接口的默认方法和静态方法
2.3 方法引用
2.4 重复注解
2.5 更好的类型推断
2.6 拓宽注解的应用场景
3. Java编译器的新特性
3.1 参数名称
4. Java官方库的新特性
4.1 Optional
4.2 Streams
4.3 Date/Time API(JSR 310)
4.4 Nashorn JavaScript引擎
4.5 Base64
4.6 并行数组
4.7 并发性
5. 新的Java工具
5.1 Nashorn引擎：jjs
5.2 类依赖分析器：jdeps
6. JVM的新特性
使用Metaspace（JEP 122）代替持久代（PermGen space）。在JVM参数方面，使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。
```

