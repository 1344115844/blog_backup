- Java 序列化机制 serialize 接口

1. 1. Java 本身的序列化机制存在的问题

   2. 1. 序列化数据结果比较大，传输效率比较低
      2. 不能跨语言对接

   3. 所以xml编码格式的对象序列化机制成了主流 过时

   4. HTTP RESTful 风格 目前主流

   5. MessagePack 框架

   6. Protocol Buffers 框架

   7. kryo 框架

> 恰当的序列化协议不仅可以提高系统的通用性，强壮型，安全性，优化性能，同时还能让系统更加易于调试和扩展

- 序列化和反序列化的概念

> 把对象转化为字节序列的过程称之为对象的序列化
>
> 反之则称为反序列化

- 实现一个序列化、反序列化操作

- - 序列化操作

1. 1. 1. 类实现serializable接口
      2. 创建输出流
      3. 写出到文件  ObjectOutputStream

2. - 反序列化操作

   - - 拿到序列化的二进制流         
     - 对象强转 ObjectInputStream

- serialVersionID的作用

  1. 保证序列化对象和反序列化得对象是同一个		

- 注意：

  1. 静态变量的序列化

     序列化并不保存静态变量的状态

  2. transient关键字

     不参与序列化

  3. 父类没有实现serializable，子类实现了serializable，父类的属性不会序列化。

  4. 对同一个对象做重复序列化，会引用，不会重复写

- 序列化可以实现深度克隆

  - 浅克隆：复制对象的基本类型，引用类型只复制内存地址，这样克隆对象和原对象都是指向同一个内存地址
  - 深克隆：全都复制，引用类型会拷贝一个新的引用对象开辟新的内存空间存放引用对象。

总结

1. 在Java中，只要一个类实现了java.io.serializable接口，那么是可以进行序列化
2. 通过objectOutputStream 和 ObjectInputStream对对象进行序列化
3. 对象是否允许被反序列化，不仅仅是取决于对象的代码是否一致，同时还有uid（序列化版本id）
4. 序列化不保存静态变量
5. 要想父类对象也参与序列化，那么让父类也实现serializable 
6. transient ，控制变量能否被序列化
7. 通过序列化操作深度克隆

主流的序列化技术

1. json
2. hessian
3. xml
4. protobuf Google开源
5. kryo 性能比较高
6. MsgPack
7. FST 性能比较高
8. thrift
9. protoStuff
10. Avro
11. 

