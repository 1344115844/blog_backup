# 控制多线程的执行顺序

### 示例代码的码云地址：https://gitee.com/suwenguang/test/blob/master/fuxi/src/main/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%8E%A7%E5%88%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C/App.java

多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。

我们在运行多线程的程序时，假设线程逐一启动的，但是发现线程的执行并不是逐一执行的。这是因为CPU随机调度的问题，谁分配到CPU谁就执行，如果好奇进程调度算法可以自行Google。

大概的思路可以这样子理一下：

程序启动->CPU分配内存给Java进程->Java进程的程序建立线程->进程分配线程空间->**线程随机获取CPU执行**->线程结束->主线程结束，进程销毁

这里关键是线程是随机获取CPU执行的

## 想要控制线程的执行顺序应该怎么做？

1. 使用join()方法
2. 使用SingleThreadExecutor线程池

## 使用join()方法

```java
public void joinTest() throws InterruptedException {
//        通过join() 方法保证线程的顺序，但是这样子就和单线程没什么区别了。
//        join()是让主线程等待子线程结束后 继续运行
        thread1.start();
        thread1.join();

        thread2.start();
        thread2.join();

        thread3.start();
        thread3.join();
    }
```

join()是让主线程等待子线程结束后，继续运行。



## 使用SingleThreadExecutor线程池

```Java
/**
 * 通过singleThreadPool来控制线程顺序，singleThreadPool是FIFO先进先出的一个线程池
 */
@Test
public void executorTest(){
    executorService.submit(thread1);
    executorService.submit(new Runnable() {
        @Override
        public void run() {
            System.out.println("i am second");
        }
    });
    executorService.submit(() -> System.out.println("i am third"));
    executorService.submit(thread2);
    executorService.submit(thread3);
}
```

其作用类似于线程队列，提交任务到队列，线程池负责调度，并根据先进先出的规则执行，这样就可以保证线程的顺序执行了。