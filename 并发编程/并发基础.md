# 并行计算基础

## 为什么需要并行

-  Linus Torvalds ：并行计算只有在 图像处理 和 服务端编程 2个领域可以使用，并且它在这2个领域确实有着大量广泛的使用。但是在其它任何地方，并行计算毫无建树！

### 并行计算还出于业务模型的需要

-  并不是为了提高系统性能，而是确实在业务上需要多个执行单元。
-  比如HTTP服务器，为每一个Socket连接新建一个处理线程
-  让不同线程承担不同的业务工作
-  简化任务调度

## 几个重要的概念

- 同步（synchronous）和异步（asynchronous）
- 并发（Concurrency）和并行（Parallelism）
- 临界区
- 阻塞（Blocking）和非阻塞（Non-Blocking）
- 锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）
- 并行的级别

### 1.同步（synchronous）和异步（asynchronous）

![1530195286733](C:\Users\13441\Desktop\md\并发编程\并发基础.assets\1530195286733.png)

### 2.并发（Concurrency）和并行（Parallelism）

![1530195325986](C:\Users\13441\Desktop\md\并发编程\并发基础.assets\1530195325986.png)

### 3.临界区

临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次，只能有一个线程
使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。

![1530195360171](C:\Users\13441\Desktop\md\并发编程\并发基础.assets\1530195360171.png)

### 4.阻塞（Blocking）和非阻塞（Non-Blocking）

阻塞和非阻塞通常用来形容多线程间的相互影响。

比如一个线程占用了临界区资源，那么其它所有需要
这个资源的线程就必须在这个临界区中进行等待，等待会导致线程挂起。这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其它所有阻塞在这个临界区上的线程都不能工作。

非阻塞允许多个线程同时进入临界区

### 5.死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）

饥饿是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行.

### 6.并发级别

1. 阻塞

   当一个线程进入临界区后，其他线程必须等待

2. 非阻塞

   1. 无障碍

      无障碍是一种最弱的非阻塞调度,自由出入临界区,无竞争时，有限步内完成操作,有竞争时，回滚数据

   2. 无锁

      是无障碍的,保证有一个线程可以胜出

   3. 无等待

      无锁的,要求所有的线程都必须在有限步内完成,无饥饿的

## 有关并行的2个重要定律

### Amdahl定律（阿姆达尔定律）

Amdahl定律（阿姆达尔定律）
– 定义了串行系统并行化后的加速比的计算公式和理论上限
**– 加速比定义：加速比=优化前系统耗时/优化后系统耗时**

![1530195842777](C:\Users\13441\Desktop\md\并发编程\并发基础.assets\1530195842777.png)

加速比= 优化前系统耗时/ 优化后系统耗时=500/400=1.25

![1530195859179](C:\Users\13441\Desktop\md\并发编程\并发基础.assets\1530195859179.png)

#### 结论：

增加CPU处理器的数量并不一定能起到有效的作用,提高系统内可并行化的模块比重，合理增加并行处理器数量才能以最小的投入，得到最大的加速比

### Gustafson定律（古斯塔夫森）

说明处理器个数，串行比例和加速比之间的关系

![1530195944340](C:\Users\13441\Desktop\md\并发编程\并发基础.assets\1530195944340.png)

#### 结论：

只要有足够的并行化，那么加速比和CPU个数成正比

## 线程的基本操作

### 中断线程

```
public void Thread.interrupt() // 中断线程
public boolean Thread.isInterrupted() // 判断是否被中断
public static boolean Thread.interrupted() // 判断是否被中断，并清除当前中断状态
```

### 挂起（suspend）和继续执行（resume）线程

– suspend()不会释放锁
– 如果加锁发生在resume()之前 ，则死锁发生

### 等待线程结束（join）和谦让(yeild)

```
public final void join() throws InterruptedException
public final synchronized void join(long millis) throws InterruptedException
static void yield() 对调度程序的一个暗示，即当前线程愿意产生当前使用的处理器。  
```

线程执行完毕后，系统会调用notifyAll();

**不要在Thread实例上使用 wait()和notify()方法**

### 守护线程

1. 在后台默默地完成一些系统性的服务，比如垃圾回收线程、[JIT线程](https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html)就可以理解为守护线程
2. 当一个Java应用内，只有守护线程时，Java虚拟机就会自然退出

### 线程优先级

```
public final static int MIN_PRIORITY = 1;
public final static int NORM_PRIORITY = 5;
public final static int MAX_PRIORITY = 10;

Thread high=new HightPriority();
LowPriority low=new LowPriority();
high.setPriority(Thread.MAX_PRIORITY);
low.setPriority(Thread.MIN_PRIORITY);
low.start();
high.start();
```

### 基本的线程同步操作

####  synchronized

– 指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁。
– 直接作用于实例方法：相当于对当前实例加锁，进入同步代码前要获得当前实例的锁。
– 直接作用于静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁。

### Object.wait() Obejct.notify()

![1530199624778](C:\Users\13441\Desktop\md\并发编程\并发基础.assets\1530199624778.png)

